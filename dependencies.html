<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dependencies</title>
    <style>
      body {
        background-color: black;
      }
      h1 {
        font-family: Arial, Helvetica, sans-serif;
        color: white;
        text-align: center;
      }
      canvas {
        display: block;
        margin: 20px auto;
        border: 1px solid rgba(96, 125, 139, 0.25);
      }
    </style>
  </head>
  <body>
    <h1>Job Dependencies</h1>
    <canvas></canvas>
    <script>
      /*
      data-structure:
      [
        {
          name: "JobName",
          dependencies: ["Dependency1", "Dependency2"],
          color: "#ColorCode", // Optional: color for the job box
          dashed: true, // Optional: if true, the line will be dashed
          strokeColor: "#StrokeColor" // Optional: color for the dependency line
        },
      ]
      */
      const deps = [
        { name: "Start", dependencies: [], color: "#7E57C2" },
        { name: "Init1", dependencies: ["Start"], color: "#1E88E5" },
        { name: "Init2", dependencies: ["Start"], color: "#43A047" },
        { name: "JobA", dependencies: ["Init1"], strokeColor: "#FF5722" },
        { name: "JobB", dependencies: ["Init1"], dashed: true, strokeColor: "#FF9800" },
        { name: "JobC", dependencies: ["Init2"], color: "#F4511E" },
        { name: "JobD", dependencies: ["Init2"], dashed: true, strokeColor: "#8E24AA" },
        { name: "Process1", dependencies: ["JobA", "JobB"], color: "#3949AB" },
        { name: "Process2", dependencies: ["JobC", "JobD"], color: "#039BE5" },
        { name: "Merge1", dependencies: ["Process1", "Process2"], color: "#6D4C41" },
        { name: "Branch1", dependencies: ["Merge1"], color: "#FF7043" },
        { name: "Branch2", dependencies: ["Merge1"], color: "#5C6BC0" },
        { name: "Branch3", dependencies: ["Merge1"], color: "#26A69A" },
        { name: "Task1", dependencies: ["Branch1"], dashed: true, strokeColor: "#FFEB3B" },
        { name: "Task2", dependencies: ["Branch2"], dashed: true, strokeColor: "#FFC107" },
        { name: "Task3", dependencies: ["Branch3"], dashed: true, strokeColor: "#FF5722" },
        { name: "SubTask1", dependencies: ["Task1"], color: "#8BC34A" },
        { name: "SubTask2", dependencies: ["Task2"], color: "#CDDC39" },
        { name: "SubTask3", dependencies: ["Task3"], color: "#FF9800" },
        { name: "FinalTask", dependencies: ["SubTask1", "SubTask2", "SubTask3"], color: "#9C27B0" },
        { name: "Review", dependencies: ["FinalTask"], color: "#3F51B5" },
        { name: "Approval", dependencies: ["Review"], color: "#009688" },
        { name: "End", dependencies: ["Approval", "Start"], color: "#7E57C2" },

        // Additional jobs and dependencies
        { name: "Extra1", dependencies: ["Init1"], color: "#FF6F00" },
        { name: "Extra2", dependencies: ["Init2"], color: "#D84315" },
        { name: "ExtraProcess1", dependencies: ["Extra1", "JobA"], color: "#4CAF50" },
        { name: "ExtraProcess2", dependencies: ["Extra2", "JobC"], color: "#03A9F4" },
        { name: "ExtraMerge", dependencies: ["ExtraProcess1", "ExtraProcess2"], color: "#9E9D24" },
        { name: "ExtraBranch1", dependencies: ["ExtraMerge"], color: "#FF5722" },
        { name: "ExtraBranch2", dependencies: ["ExtraMerge"], color: "#607D8B" },
        { name: "ExtraTask1", dependencies: ["ExtraBranch1"], dashed: true, strokeColor: "#FFC107" },
        { name: "ExtraTask2", dependencies: ["ExtraBranch2"], dashed: true, strokeColor: "#FF9800" },
        { name: "ExtraSubTask1", dependencies: ["ExtraTask1"], color: "#8BC34A" },
        { name: "ExtraSubTask2", dependencies: ["ExtraTask2"], color: "#CDDC39" },
        { name: "ExtraFinal", dependencies: ["ExtraSubTask1", "ExtraSubTask2"], color: "#9C27B0" },
        { name: "ExtraReview", dependencies: ["ExtraFinal"], color: "#3F51B5" },
        { name: "ExtraApproval", dependencies: ["ExtraReview"], color: "#009688" },
        { name: "ExtraEnd", dependencies: ["ExtraApproval"], color: "#7E57C2" },

        // Deep branching
        { name: "Deep1", dependencies: ["ExtraEnd"], color: "#FF7043" },
        { name: "Deep2", dependencies: ["Deep1"], color: "#5C6BC0" },
        { name: "Deep3", dependencies: ["Deep2"], color: "#26A69A" },
        { name: "Deep4", dependencies: ["Deep3"], color: "#FFEB3B" },
        { name: "Deep5", dependencies: ["Deep4"], color: "#FFC107" },
        { name: "Deep6", dependencies: ["Deep5"], color: "#FF5722" },
        { name: "DeepFinal", dependencies: ["Deep6"], color: "#8BC34A" },
      ];

      const sortedDeps = sortDeps(deps); // Sort dependencies to ensure correct rendering order

      const canvas = document.querySelector("canvas");
      const ctx = canvas.getContext("2d");
      const canvasPadding = 50;

      const defaultLineColor = "#263238"; // Default line color for dependencies
      const defaultBoxColor = "#607D8B"; // Default box color for jobs without a specific color
      const highlightColor = "white"; // Color for highlighted jobs
      const boxWidth = 150;
      const boxHeight = 50;
      const horizontalSpacing = 60;
      const verticalSpacing = 30;
      const fontSize = 16;
      const lineWidth = 2;
      const arrowSize = 10;

      // Calculate positions for each job dynamically
      const positions = {};
      const levels = {};
      let hoveredJob = null; // Variable to track the hovered job

      // Assign levels to jobs based on dependencies
      sortedDeps.forEach((job) => {
        if (job.dependencies.length === 0) {
          levels[job.name] = 0; // Root level
        } else {
          levels[job.name] = Math.max(...job.dependencies.map((dep) => levels[dep] || 0)) + 1;
        }
      });

      // Group jobs by levels
      const jobsByLevel = Object.entries(levels).reduce((acc, [job, level]) => {
        acc[level] = acc[level] || [];
        acc[level].push(job);
        return acc;
      }, {});

      // Calculate the required canvas size
      const maxLevel = Math.max(...Object.values(levels));
      const maxJobsInLevel = Math.max(...Object.values(jobsByLevel).map((jobs) => jobs.length));
      const canvasWidth = maxJobsInLevel * (boxWidth + horizontalSpacing) + 50; // Add padding
      const canvasHeight = (maxLevel + 1) * (boxHeight + verticalSpacing) + 50; // Add padding

      // Set the canvas size dynamically
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      // Assign positions based on levels and order within levels
      Object.entries(jobsByLevel).forEach(([level, jobs]) => {
        jobs.forEach((job, index) => {
          const x = canvasPadding + index * (boxWidth + horizontalSpacing); // Add padding
          const y = canvasPadding + level * (boxHeight + verticalSpacing); // Add padding
          positions[job] = { x, y };
        });
      });

      function sortDeps(deps) {
        const sorted = [];
        const visited = new Set();

        // Helper function for depth-first traversal
        function visit(job) {
          if (visited.has(job.name)) return; // Skip already visited jobs
          visited.add(job.name);

          // Visit all dependencies first
          job.dependencies.forEach((depName) => {
            const dep = deps.find((j) => j.name === depName);
            if (dep) visit(dep);
          });

          // Add the job to the sorted list
          sorted.push(job);
        }

        // Visit all jobs in the deps array
        deps.forEach((job) => visit(job));

        return sorted;
      }

      // Function to find all dependencies recursively
      function findDependencies(jobName, chain = []) {
        const job = sortedDeps.find((j) => j.name === jobName);
        if (!job || chain.includes(jobName)) return chain;
        chain.push(jobName);
        job.dependencies.forEach((dep) => findDependencies(dep, chain));
        return chain;
      }

      // Function to draw an arrowhead at the start of the line
      function drawArrowhead(ctx, fromX, fromY, toX, toY, arrowSize, color) {
        const angle = Math.atan2(toY - fromY, toX - fromX); // Calculate the angle of the line

        // Coordinates for the two sides of the arrowhead
        const arrowX1 = fromX + arrowSize * Math.cos(angle - Math.PI / 6);
        const arrowY1 = fromY + arrowSize * Math.sin(angle - Math.PI / 6);
        const arrowX2 = fromX + arrowSize * Math.cos(angle + Math.PI / 6);
        const arrowY2 = fromY + arrowSize * Math.sin(angle + Math.PI / 6);

        // Draw the arrowhead
        ctx.beginPath();
        ctx.moveTo(fromX, fromY); // Tip of the arrow
        ctx.lineTo(arrowX1, arrowY1); // Left side of the arrowhead
        ctx.lineTo(arrowX2, arrowY2); // Right side of the arrowhead
        ctx.closePath();
        ctx.fillStyle = color; // Arrow color
        ctx.fill();
      }

      function cropJobNameText(jobname) {
        const maxLength = 17; // Maximum length of the job name
        if (jobname.length > maxLength) {
          return jobname.substring(0, maxLength - 3) + "..."; // Crop and add ellipsis
        }
        return jobname; // Return original name if within limit
      }

      // Draw the jobs and dependencies
      function drawDependencies() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw boxes for jobs first
        sortedDeps.forEach((job) => {
          const { x, y } = positions[job.name];
          const isHighlighted = hoveredJob && findDependencies(hoveredJob).includes(job.name);

          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = isHighlighted ? highlightColor : job.color ? job.color : defaultBoxColor;
          ctx.strokeRect(x, y, boxWidth, boxHeight);
          ctx.fillStyle = isHighlighted ? highlightColor : job.color ? job.color : defaultBoxColor;
          ctx.font = `bold ${fontSize}px Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(cropJobNameText(job.name), x + boxWidth / 2, y + boxHeight / 2);
        });

        // Draw lines for dependencies after the boxes
        sortedDeps.forEach((job) => {
          const { x: startX, y: startY } = positions[job.name];

          job.dependencies.forEach((dep, index) => {
            const { x: endX, y: endY } = positions[dep];

            // Offset the line slightly based on the index of the dependency
            const offset = (index - job.dependencies.length / 2) * 10; // Adjust offset dynamically
            const isHighlighted = hoveredJob && findDependencies(hoveredJob).includes(job.name);

            // Draw the line
            ctx.beginPath();
            if (job.dashed) {
              ctx.setLineDash([5, 10]);
            }
            ctx.moveTo(startX + boxWidth / 2 + offset, startY); // Start with an offset
            ctx.lineTo(endX + boxWidth / 2 + offset, endY + boxHeight); // End with the same offset
            ctx.strokeStyle = isHighlighted
              ? highlightColor // Highlighted lines are white
              : job.strokeColor || defaultLineColor; // Use job stroke color or default
            ctx.lineWidth = lineWidth; // Make the lines more visible
            ctx.stroke();
            ctx.setLineDash([]); // reset the line dash style

            // Draw the arrowhead at the start of the line
            drawArrowhead(
              ctx,
              startX + boxWidth / 2 + offset,
              startY,
              endX + boxWidth / 2 + offset,
              endY + boxHeight,
              arrowSize,
              isHighlighted
                ? highlightColor // Highlighted lines are white
                : job.strokeColor || defaultLineColor
            );
          });
        });
      }
      // Function to handle mouse movement
      function handleMouseMove(event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        // Check if the mouse is over any box
        hoveredJob = null;
        for (const job of deps) {
          const { x, y } = positions[job.name];
          if (mouseX >= x && mouseX <= x + boxWidth && mouseY >= y && mouseY <= y + boxHeight) {
            hoveredJob = job.name;
            break;
          }
        }
        drawDependencies();
      }
      // Attach the mousemove event listener
      canvas.addEventListener("mousemove", handleMouseMove);

      drawDependencies();
    </script>
  </body>
</html>
