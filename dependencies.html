<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dependencies</title>
    <style>
      body {
        background-color: black;
      }
      h1 {
        font-family: Arial, Helvetica, sans-serif;
        color: white;
        text-align: center;
      }
      canvas {
        display: block;
        margin: 20px auto;
      }
    </style>
  </head>
  <body>
    <h1>Job Dependencies</h1>
    <canvas></canvas>
    <script>
      const deps = [
        { name: "Start", dependencies: [], color: "#7E57C2" },
        { name: "Job1", dependencies: ["Start"] },
        { name: "Job2a", dependencies: ["Job1"] },
        { name: "Job2b", dependencies: ["Job1"], dashed: true, strokeColor: "#FF5722" },
        { name: "Job2c", dependencies: ["Job1"] },
        { name: "Job3", dependencies: ["Job2a", "Job2b", "Job2c"] },
        { name: "Job4", dependencies: ["Job2c"] },
        { name: "Job5", dependencies: ["Job4"] },
        { name: "Job6", dependencies: ["Job5"] },
        { name: "End", dependencies: ["Job6"], color: "#7E57C2" },
      ];

      const canvas = document.querySelector("canvas");
      const ctx = canvas.getContext("2d");

      const defaultLineColor = "#263238"; // Default line color for dependencies
      const defaultBoxColor = "#607D8B"; // Default box color for jobs without a specific color
      const highlightColor = "white"; // Color for highlighted jobs
      const boxWidth = 150;
      const boxHeight = 50;
      const horizontalSpacing = 60;
      const verticalSpacing = 30;

      // Calculate positions for each job dynamically
      const positions = {};
      const levels = {};
      let hoveredJob = null; // Variable to track the hovered job

      // Assign levels to jobs based on dependencies
      deps.forEach((job) => {
        if (job.dependencies.length === 0) {
          levels[job.name] = 0; // Root level
        } else {
          levels[job.name] = Math.max(...job.dependencies.map((dep) => levels[dep] || 0)) + 1;
        }
      });

      // Group jobs by levels
      const jobsByLevel = Object.entries(levels).reduce((acc, [job, level]) => {
        acc[level] = acc[level] || [];
        acc[level].push(job);
        return acc;
      }, {});

      // Calculate the required canvas size
      const maxLevel = Math.max(...Object.values(levels));
      const maxJobsInLevel = Math.max(...Object.values(jobsByLevel).map((jobs) => jobs.length));
      const canvasWidth = maxJobsInLevel * (boxWidth + horizontalSpacing) + 50; // Add padding
      const canvasHeight = (maxLevel + 1) * (boxHeight + verticalSpacing) + 50; // Add padding

      // Set the canvas size dynamically
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      // Assign positions based on levels and order within levels
      Object.entries(jobsByLevel).forEach(([level, jobs]) => {
        jobs.forEach((job, index) => {
          const x = 50 + index * (boxWidth + horizontalSpacing); // Add padding
          const y = 50 + level * (boxHeight + verticalSpacing); // Add padding
          positions[job] = { x, y };
        });
      });

      // Function to find all dependencies recursively
      function findDependencies(jobName, chain = []) {
        const job = deps.find((j) => j.name === jobName);
        if (!job || chain.includes(jobName)) return chain;
        chain.push(jobName);
        job.dependencies.forEach((dep) => findDependencies(dep, chain));
        return chain;
      }

      // Function to draw an arrowhead at the start of the line
      function drawArrowhead(ctx, fromX, fromY, toX, toY, arrowSize, color) {
        const angle = Math.atan2(toY - fromY, toX - fromX); // Calculate the angle of the line

        // Coordinates for the two sides of the arrowhead
        const arrowX1 = fromX + arrowSize * Math.cos(angle - Math.PI / 6);
        const arrowY1 = fromY + arrowSize * Math.sin(angle - Math.PI / 6);
        const arrowX2 = fromX + arrowSize * Math.cos(angle + Math.PI / 6);
        const arrowY2 = fromY + arrowSize * Math.sin(angle + Math.PI / 6);

        // Draw the arrowhead
        ctx.beginPath();
        ctx.moveTo(fromX, fromY); // Tip of the arrow
        ctx.lineTo(arrowX1, arrowY1); // Left side of the arrowhead
        ctx.lineTo(arrowX2, arrowY2); // Right side of the arrowhead
        ctx.closePath();
        ctx.fillStyle = color; // Arrow color
        ctx.fill();
      }

      function cropJobNameText(jobname) {
        const maxLength = 17; // Maximum length of the job name
        if (jobname.length > maxLength) {
          return jobname.substring(0, maxLength - 3) + "..."; // Crop and add ellipsis
        }
        return jobname; // Return original name if within limit
      }

      // Draw the jobs and dependencies
      function drawDependencies() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw boxes for jobs first
        deps.forEach((job) => {
          const { x, y } = positions[job.name];
          const isHighlighted = hoveredJob && findDependencies(hoveredJob).includes(job.name);

          ctx.lineWidth = 2;
          ctx.strokeStyle = isHighlighted ? highlightColor : job.color ? job.color : defaultBoxColor;
          ctx.strokeRect(x, y, boxWidth, boxHeight);
          ctx.fillStyle = isHighlighted ? highlightColor : job.color ? job.color : defaultBoxColor;
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(cropJobNameText(job.name), x + boxWidth / 2, y + boxHeight / 2);
        });

        // Draw lines for dependencies after the boxes
        deps.forEach((job) => {
          const { x: startX, y: startY } = positions[job.name];

          job.dependencies.forEach((dep, index) => {
            const { x: endX, y: endY } = positions[dep];

            // Offset the line slightly based on the index of the dependency
            const offset = (index - job.dependencies.length / 2) * 10; // Adjust offset dynamically
            const isHighlighted = hoveredJob && findDependencies(hoveredJob).includes(job.name);

            // Draw the line
            ctx.beginPath();
            if (job.dashed) {
              ctx.setLineDash([5, 10]);
            }
            ctx.moveTo(startX + boxWidth / 2 + offset, startY); // Start with an offset
            ctx.lineTo(endX + boxWidth / 2 + offset, endY + boxHeight); // End with the same offset
            ctx.strokeStyle = isHighlighted
              ? highlightColor // Highlighted lines are white
              : job.strokeColor || defaultLineColor; // Use job stroke color or default
            ctx.lineWidth = 2; // Make the lines more visible
            ctx.stroke();
            ctx.setLineDash([]); // reset the line dash style

            // Draw the arrowhead at the start of the line
            drawArrowhead(
              ctx,
              startX + boxWidth / 2 + offset,
              startY,
              endX + boxWidth / 2 + offset,
              endY + boxHeight,
              10,
              isHighlighted
                ? highlightColor // Highlighted lines are white
                : job.strokeColor || defaultLineColor
            );
          });
        });
      }
      // Function to handle mouse movement
      function handleMouseMove(event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        // Check if the mouse is over any box
        hoveredJob = null;
        for (const job of deps) {
          const { x, y } = positions[job.name];
          if (mouseX >= x && mouseX <= x + boxWidth && mouseY >= y && mouseY <= y + boxHeight) {
            hoveredJob = job.name;
            break;
          }
        }
        drawDependencies();
      }
      // Attach the mousemove event listener
      canvas.addEventListener("mousemove", handleMouseMove);

      drawDependencies();
    </script>
  </body>
</html>
